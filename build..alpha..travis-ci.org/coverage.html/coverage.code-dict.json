{"/home/travis/build/npmtest/node-npmtest-sails-mongo/test.js":"/* istanbul instrument in package npmtest_sails_mongo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sails-mongo/lib.npmtest_sails_mongo.js":"/* istanbul instrument in package npmtest_sails_mongo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_sails_mongo = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_sails_mongo = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-sails-mongo/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-sails-mongo && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_sails_mongo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_sails_mongo\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_sails_mongo.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_sails_mongo.rollup.js'] =\n            local.assetsDict['/assets.npmtest_sails_mongo.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_sails_mongo.__dirname +\n                    '/lib.npmtest_sails_mongo.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sails-mongo/node_modules/sails-mongo/lib/adapter.js":"/*---------------------------------------------------------------\n  :: sails-mongo\n  -> adapter\n---------------------------------------------------------------*/\n\nvar util = require('util');\nvar async = require('async');\nvar _ = require('@sailshq/lodash');\nvar ObjectId = require('mongodb').ObjectID;\nvar Errors = require('waterline-errors').adapter;\nvar _runJoins = require('waterline-cursor');\nvar Connection = require('./connection');\nvar Collection = require('./collection');\nvar utils = require('./utils');\n\n\nmodule.exports = (function() {\n\n  // Keep track of all the connections used by the app\n  var connections = {};\n\n  var adapter = {\n\n    // Which type of primary key is used by default\n    pkFormat: 'string',\n\n    // to track schema internally\n    syncable: true,\n\n    // Expose all the connection options with default settings\n    defaults: {\n\n\n      // Connection Configuration\n      host: 'localhost',\n      database: 'sails',\n      port: 27017,\n      user: null,\n      password: null,\n      schema: false,\n\n\n      // Allow a URL Config String\n      url: null,\n\n\n      // DB Options\n      w: 1,\n      wtimeout: 0,\n      fsync: false,\n      journal: false,\n      readPreference: null,\n      nativeParser: false,\n      forceServerObjectId: false,\n      recordQueryStats: false,\n      retryMiliSeconds: 5000,\n      numberOfRetries: 5,\n\n      // Server Options\n      ssl: false,\n      poolSize: 5,\n      socketOptions: {\n        noDelay: true,\n        keepAlive: 0,\n        connectTimeoutMS: 0,\n        socketTimeoutMS: 0\n      },\n      auto_reconnect: true,\n      disableDriverBSONSizeCheck: false,\n      reconnectTries: 30, // defaults to mongodb recommended settings\n      reconnectInterval: 1000, // defaults to mongodb recommended settings\n\n\n      // Waterline NEXT\n      // These are flags that can be toggled today and expose future features. If any of the following are turned\n      // on the adapter tests will probably not pass. If you toggle these know what you are getting into.\n      wlNext: {\n\n        // Case sensitive - false\n        // In the next version of WL queries will be case sensitive by default.\n        // Set this to true to experiment with that feature today.\n        caseSensitive: false\n\n      }\n\n    },\n\n    /**\n     * Register A Connection\n     *\n     * Will open up a new connection using the configuration provided and store the DB\n     * object to run commands off of. This creates a new pool for each connection config.\n     *\n     * @param {Object} connection\n     * @param {Object} collections\n     * @param {Function} callback\n     */\n\n    registerConnection: function(connection, collections, cb) {\n      if(!connection.identity) return cb(Errors.IdentityMissing);\n      if(connections[connection.identity]) return cb(Errors.IdentityDuplicate);\n\n      // Merging default options\n      connection = _.defaults(connection, this.defaults);\n\n      // Store the connection\n      connections[connection.identity] = {\n        config: connection,\n        collections: {}\n      };\n\n      // Create a new active connection\n      new Connection(connection, function(_err, db) {\n\n        if(_err) {\n          return cb((function _createError(){\n            var msg = util.format('Failed to connect to MongoDB.  Are you sure your configured Mongo instance is running?\\n Error details:\\n%s', util.inspect(_err, false, null));\n            var err = new Error(msg);\n            err.originalError = _err;\n            return err;\n          })());\n        }\n        connections[connection.identity].connection = db;\n\n        // Build up a registry of collections\n        Object.keys(collections).forEach(function(key) {\n          connections[connection.identity].collections[key] = new Collection(collections[key], db);\n        });\n\n        cb();\n      });\n\n    },\n\n    /**\n     * Teardown\n     *\n     * Closes the connection pool and removes the connection object from the registry.\n     *\n     * @param {String} connectionName\n     * @param {Function} callback\n     */\n\n    teardown: function (conn, cb) {\n      if (typeof conn == 'function') {\n        cb = conn;\n        conn = null;\n      }\n\n      if (conn === null) {\n        var _connections = _.pluck(_.values(connections), 'connection');\n        if(!_connections.length) { return cb(); }\n\n        var dbs = _.pluck(_connections, 'db');\n        if(!dbs.length) { return cb(); }\n\n        connections = {};\n        return async.each(dbs, function (db, onClosed) {\n          if(db === undefined) { return onClosed(); }\n          db.close(onClosed);\n        }, cb);\n      }\n\n      if(!connections[conn]) return cb();\n\n      var dbConnection = connections[conn].connection.db;\n      dbConnection.close(function () {\n        delete connections[conn];\n        cb();\n      });\n    },\n\n    /**\n     * Describe\n     *\n     * Return the Schema of a collection after first creating the collection\n     * and indexes if they don't exist.\n     *\n     * @param {String} connectionName\n     * @param {String} collectionName\n     * @param {Function} callback\n     */\n\n    describe: function(connectionName, collectionName, cb) {\n\n      var connectionObject = connections[connectionName];\n      var collection = connectionObject.collections[collectionName];\n      var schema = collection.schema;\n      var names = connectionObject.connection.db.listCollections(collectionName);\n      if(names.length > 0) return cb(null, schema);\n      cb();\n\n    },\n\n    /**\n     * Define\n     *\n     * Create a new Mongo Collection and set Index Values\n     *\n     * @param {String} connectionName\n     * @param {String} collectionName\n     * @param {Object} definition\n     * @param {Function} callback\n     */\n\n    define: function(connectionName, collectionName, definition, cb) {\n\n      var connectionObject = connections[connectionName];\n      var collection = connectionObject.collections[collectionName];\n\n      // Create the collection and indexes\n      connectionObject.connection.createCollection(collectionName, collection, cb);\n    },\n\n    /**\n     * Drop\n     *\n     * Drop a Collection\n     *\n     * @param {String} connectionName\n     * @param {String} collectionName\n     * @param {Array} relations\n     * @param {Function} callback\n     */\n\n    drop: function(connectionName, collectionName, relations, cb) {\n\n      if(typeof relations === 'function') {\n        cb = relations;\n        relations = [];\n      }\n\n      var connectionObject = connections[connectionName];\n      var collection = connectionObject.collections[collectionName];\n\n      // Drop the collection and indexes\n      connectionObject.connection.dropCollection(collectionName, function(err) {\n\n        // Don't error if droping a collection which doesn't exist\n        if(err && err.errmsg === 'ns not found') return cb();\n        if(err) return cb(err);\n        cb();\n      });\n    },\n\n    /**\n     * Native\n     *\n     * Give access to a native mongo collection object for running custom\n     * queries.\n     *\n     * @param {String} connectionName\n     * @param {String} collectionName\n     * @param {Function} callback\n     */\n\n    native: function(connectionName, collectionName, cb) {\n\n      var connectionObject = connections[connectionName];\n      cb(null, connectionObject.connection.db.collection(collectionName));\n\n    },\n\n    /**\n     * Mongo object with mongoDB native methods\n     */\n\n    mongo: {\n\n      /**\n       * ObjectId\n       *\n       * Return a Mongo ObjectID from a string\n       *\n       * @param {String} id\n       */\n      objectId: function(id){\n        if(!id) return null;\n        try {\n          return new ObjectId(id);\n        } catch(err) {\n          return null;\n        }\n      }\n\n    },\n\n    /**\n     * Create\n     *\n     * Insert a single document into a collection.\n     *\n     * @param {String} connectionName\n     * @param {String} collectionName\n     * @param {Object} data\n     * @param {Function} callback\n     */\n\n    create: function(connectionName, collectionName, data, cb) {\n\n      var connectionObject = connections[connectionName];\n      var collection = connectionObject.collections[collectionName];\n\n      // Insert a new document into the collection\n      collection.insert(data, function(err, results) {\n        if(err) return cb(utils.clarifyError(err));\n        cb(null, results[0]);\n      });\n    },\n\n    /**\n     * Create Each\n     *\n     * Insert an array of documents into a collection.\n     *\n     * @param {String} connectionName\n     * @param {String} collectionName\n     * @param {Object} data\n     * @param {Function} callback\n     */\n\n    createEach: function(connectionName, collectionName, data, cb) {\n\n      if (data.length === 0) {return cb(null, []);}\n\n      var connectionObject = connections[connectionName];\n      var collection = connectionObject.collections[collectionName];\n\n      // Insert a new document into the collection\n      collection.insert(data, function(err, results) {\n        if(err) return cb(utils.clarifyError(err));\n        cb(null, results);\n      });\n    },\n\n    /**\n     * Find\n     *\n     * Find all matching documents in a collection.\n     *\n     * @param {String} connectionName\n     * @param {String} collectionName\n     * @param {Object} options\n     * @param {Function} callback\n     */\n\n    find: function(connectionName, collectionName, options, cb) {\n      options = options || {};\n      var connectionObject = connections[connectionName];\n      var collection = connectionObject.collections[collectionName];\n\n      // Find all matching documents\n      collection.find(options, function(err, results) {\n        if(err) return cb(err);\n        cb(null, results);\n      });\n    },\n\n    /**\n     * Update\n     *\n     * Update all documents matching a criteria object in a collection.\n     *\n     * @param {String} connectionName\n     * @param {String} collectionName\n     * @param {Object} options\n     * @param {Object} values\n     * @param {Function} callback\n     */\n\n    update: function(connectionName, collectionName, options, values, cb) {\n      options = options || {};\n      var connectionObject = connections[connectionName];\n      var collection = connectionObject.collections[collectionName];\n\n      // Update matching documents\n      collection.update(options, values, function(err, results) {\n        if(err) return cb(utils.clarifyError(err));\n        cb(null, results);\n      });\n    },\n\n    /**\n     * Destroy\n     *\n     * Destroy all documents matching a criteria object in a collection.\n     *\n     * @param {String} connectionName\n     * @param {String} collectionName\n     * @param {Object} options\n     * @param {Function} callback\n     */\n\n    destroy: function(connectionName, collectionName, options, cb) {\n      options = options || {};\n      var connectionObject = connections[connectionName];\n      var collection = connectionObject.collections[collectionName];\n\n      // Find matching documents\n      collection.find(options, function(err, results) {\n        if(err) return cb(err);\n\n        // Destroy matching documents\n        collection.destroy(options, function(err) {\n          if(err) return cb(err);\n          cb(null, results);\n        });\n      });\n    },\n\n    /**\n     * Count\n     *\n     * Return a count of the number of records matching a criteria.\n     *\n     * @param {String} connectionName\n     * @param {String} collectionName\n     * @param {Object} options\n     * @param {Function} callback\n     */\n\n    count: function(connectionName, collectionName, options, cb) {\n      options = options || {};\n      var connectionObject = connections[connectionName];\n      var collection = connectionObject.collections[collectionName];\n\n      // Find matching documents and return the count\n      collection.count(options, function(err, results) {\n        if(err) return cb(err);\n        cb(null, results);\n      });\n    },\n\n\n    /**\n     * Join\n     *\n     * Peforms a join between 2-3 mongo collections when Waterline core\n     * needs to satisfy a `.populate()`.\n     *\n     * @param  {[type]}   connectionName [description]\n     * @param  {[type]}   collectionName [description]\n     * @param  {[type]}   criteria       [description]\n     * @param  {Function} cb             [description]\n     * @return {[type]}                  [description]\n     */\n    join: function (connectionName, collectionName, criteria, cb) {\n\n      // Ignore `select` from waterline core\n      if (typeof criteria === 'object') {\n        delete criteria.select;\n      }\n\n      var connectionObject = connections[connectionName];\n      var collection = connectionObject.collections[collectionName];\n\n      // Populate associated records for each parent result\n      // (or do them all at once as an optimization, if possible)\n      _runJoins({\n\n        instructions: criteria,\n        parentCollection: collectionName,\n\n        /**\n         * Find some records directly (using only this adapter)\n         * from the specified collection.\n         *\n         * @param  {String}   collectionIdentity\n         * @param  {Object}   criteria\n         * @param  {Function} cb\n         */\n        $find: function (collectionIdentity, criteria, cb) {\n          var connectionObject = connections[connectionName];\n          var collection = connectionObject.collections[collectionIdentity];\n          return collection.find(criteria, cb);\n        },\n\n        /**\n         * Look up the name of the primary key field\n         * for the collection with the specified identity.\n         *\n         * @param  {String}   collectionIdentity\n         * @return {String}\n         */\n        $getPK: function (collectionIdentity) {\n          if (!collectionIdentity) return;\n          var connectionObject = connections[connectionName];\n          if (!connectionObject) {\n            throw new Error('Consistency violation in sails-mongo: Unrecognized datastore (i.e. connection): `'+connectionName+'`.');\n          }\n          var collection = connectionObject.collections[collectionIdentity];\n          if (!collection) {\n            throw new Error('Consistency violation in sails-mongo: Unrecognized collection: `'+collectionIdentity+'` in datastore (i.e. connection): `'+connectionName+'`.');\n          }\n          return collection._getPK();\n        }\n      }, cb);\n\n    },\n\n    /**\n     * Stream\n     *\n     * Stream one or more documents from the collection\n     * using where, limit, skip, and order\n     * In where: handle `or`, `and`, and `like` queries\n     *\n     * @param {String} connectionName\n     * @param {String} collectionName\n     * @param {Object} options\n     * @param {Object} stream\n     */\n    stream: function(connectionName, collectionName, options, stream) {\n      options = options || {};\n      var connectionObject = connections[connectionName];\n      var collection = connectionObject.collections[collectionName];\n\n      collection.stream(options, stream);\n    },\n\n    identity: 'sails-mongo'\n  };\n\n  return adapter;\n})();\n","/home/travis/build/npmtest/node-npmtest-sails-mongo/node_modules/sails-mongo/lib/connection.js":"\n/**\n * Module dependencies\n */\n\nvar async = require('async'),\n    MongoClient = require('mongodb').MongoClient;\n\n/**\n * Manage a connection to a Mongo Server\n *\n * @param {Object} config\n * @return {Object}\n * @api private\n */\n\nvar Connection = module.exports = function Connection(config, cb) {\n  var self = this;\n\n  // Hold the config object\n  this.config = config || {};\n\n  // Build Database connection\n  this._buildConnection(function(err, db) {\n    if(err) return cb(err);\n    if(!db) return cb(new Error('no db object'));\n\n    // Store the DB object\n    self.db = db;\n\n    // Return the connection\n    cb(null, self);\n  });\n};\n\n\n/////////////////////////////////////////////////////////////////////////////////\n// PUBLIC METHODS\n/////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Create A Collection\n *\n * @param {String} name\n * @param {Object} collection\n * @param {Function} callback\n * @api public\n */\n\nConnection.prototype.createCollection = function createCollection(name, collection, cb) {\n  var self = this;\n\n  // Create the Collection\n  this.db.createCollection(name, function(err, result) {\n    if(err) return cb(err);\n\n    // Create Indexes\n    self._ensureIndexes(result, collection.indexes, cb);\n  });\n};\n\n/**\n * Drop A Collection\n *\n * @param {String} name\n * @param {Function} callback\n * @api public\n */\n\nConnection.prototype.dropCollection = function dropCollection(name, cb) {\n  this.db.dropCollection(name, cb);\n};\n\n\n/////////////////////////////////////////////////////////////////////////////////\n// PRIVATE METHODS\n/////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Build Server and Database Connection Objects\n *\n * @param {Function} callback\n * @api private\n */\n\nConnection.prototype._buildConnection = function _buildConnection(cb) {\n\n  // Set the configured options\n  var connectionOptions = {};\n  \n  connectionOptions.mongos = this.config.mongos || {};\n  connectionOptions.replSet = this.config.replSet || {};\n\n  // Build up options used for creating a Server instance\n  connectionOptions.server = {\n    readPreference: this.config.readPreference,\n    ssl: this.config.ssl,\n    sslValidate: this.config.sslValidate,\n    sslCA: this.config.sslCA,\n    sslCert: this.config.sslCert,\n    sslKey: this.config.sslKey,\n    poolSize: this.config.poolSize,\n    socketOptions: this.config.socketOptions,\n    autoReconnect: this.config.auto_reconnect,\n    disableDriverBSONSizeCheck: this.config.disableDriverBSONSizeCheck,\n    reconnectInterval: this.config.reconnectInterval,\n    reconnectTries: this.config.reconnectTries\n  };\n\n  // Build up options used for creating a Database instance\n  connectionOptions.db = {\n    w: this.config.w,\n    wtimeout: this.config.wtimeout,\n    fsync: this.config.fsync,\n    journal: this.config.journal,\n    readPreference: this.config.readPreference,\n    native_parser: this.config.nativeParser,\n    forceServerObjectId: this.config.forceServerObjectId,\n    recordQueryStats: this.config.recordQueryStats,\n    retryMiliSeconds: this.config.retryMiliSeconds,\n    numberOfRetries: this.config.numberOfRetries\n  };\n\n  // Support for encoded auth credentials\n  connectionOptions.uri_decode_auth = this.config.uri_decode_auth || false;\n\n  // Build A Mongo Connection String\n  var connectionString = 'mongodb://';\n\n  // If auth is used, append it to the connection string\n  if(this.config.user && this.config.password) {\n\n    // Ensure a database was set if auth in enabled\n    if(!this.config.database) {\n      throw new Error('The MongoDB Adapter requires a database config option if authentication is used.');\n    }\n\n    connectionString += this.config.user + ':' + this.config.password + '@';\n  }\n\n  // Append the host and port\n  connectionString += this.config.host + ':' + this.config.port + '/';\n\n  if(this.config.database) {\n    connectionString += this.config.database;\n  }\n\n  // Use config connection string if available\n  if(this.config.url) connectionString = this.config.url;\n\n  // Open a Connection\n  MongoClient.connect(connectionString, connectionOptions, cb);\n};\n\n/**\n * Ensure Indexes\n *\n * @param {String} collection\n * @param {Array} indexes\n * @param {Function} callback\n * @api private\n */\n\nConnection.prototype._ensureIndexes = function _ensureIndexes(collection, indexes, cb) {\n  var self = this;\n\n  function createIndex(item, next) {\n    collection.ensureIndex(item.index, item.options, next);\n  }\n\n  async.each(indexes, createIndex, cb);\n};\n","/home/travis/build/npmtest/node-npmtest-sails-mongo/node_modules/sails-mongo/lib/collection.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar async = require('async');\nvar ObjectId = require('mongodb').ObjectID;\nvar Errors = require('waterline-errors').adapter;\nvar utils = require('./utils');\nvar Document = require('./document');\nvar Query = require('./query');\n\n\n/**\n * Manage A Collection\n *\n * @param {Object} definition\n * @api public\n */\n\nvar Collection = module.exports = function Collection(definition, connection) {\n\n  // Set an identity for this collection\n  this.identity = '';\n\n  // Hold Schema Information\n  this.schema = null;\n\n  // Hold a reference to an active connection\n  this.connection = connection;\n\n  // Hold the config object\n  var connectionConfig = connection.config || {};\n  this.config = _.extend({}, connectionConfig.wlNext);\n\n  // Hold Indexes\n  this.indexes = [];\n\n  // Parse the definition into collection attributes\n  this._parseDefinition(definition);\n\n  // Build an indexes dictionary\n  this._buildIndexes();\n\n  return this;\n};\n\n\n/////////////////////////////////////////////////////////////////////////////////\n// PUBLIC METHODS\n/////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Find Documents\n *\n * @param {Object} criteria\n * @param {Function} callback\n * @api public\n */\n\nCollection.prototype.find = function find(criteria, cb) {\n  var self = this,\n      query;\n\n  // Catch errors from building query and return to the callback\n  try {\n    query = new Query(criteria, this.schema, this.config);\n  } catch(err) {\n    return cb(err);\n  }\n\n  var collection = this.connection.db.collection(self.identity);\n\n  // Check for aggregate query\n  if(query.aggregate) {\n    var aggregate = [\n      { '$match': query.criteria.where || {} },\n      { '$group': query.aggregateGroup }\n    ];\n\n    return collection.aggregate(aggregate, function(err, results) {\n\n      // Results have grouped by values under _id, so we extract them\n      var mapped = results.map(function(result) {\n        for(var key in result._id) {\n          result[key] = result._id[key];\n        }\n        delete result._id;\n        return result;\n      });\n\n      cb(err, mapped);\n    });\n  }\n\n  var where = query.criteria.where || {};\n  var queryOptions = _.omit(query.criteria, 'where');\n\n  // Run Normal Query on collection\n  collection.find(where, query.select, queryOptions).toArray(function(err, docs) {\n    if(err) return cb(err);\n    cb(null, utils.normalizeResults(docs, self.schema));\n  });\n};\n\n/**\n * Stream Documents\n *\n * @param {Object} criteria\n * @param {Object} stream\n * @api public\n */\nCollection.prototype.stream = function find(criteria, stream) {\n  var self = this,\n    query;\n\n  // Ignore `select` from waterline core\n  if (typeof criteria === 'object') {\n    delete criteria.select;\n  }\n\n  // Catch errors from building query and return to the callback\n  try {\n    query = new Query(criteria, this.schema, this.config);\n  } catch(err) {\n    return stream.end(err); // End stream\n  }\n\n  var collection = this.connection.db.collection(self.identity);\n\n  var where = query.criteria.where || {};\n  var queryOptions = _.omit(query.criteria, 'where');\n\n  // Run Normal Query on collection\n  var dbStream = collection.find(where, queryOptions).stream();\n\n  // For each data item\n  dbStream.on('data', function(item) {\n    // Pause stream\n    dbStream.pause();\n\n    var obj = utils.rewriteIds([item], self.schema)[0];\n\n    stream.write(obj, function() {\n      dbStream.resume();\n    });\n\n  });\n\n  // Handle error, an 'end' event will be emitted after this as well\n  dbStream.on('error', function(err) {\n    stream.end(err); // End stream\n  });\n\n  // all rows have been received\n  dbStream.on('close', function() {\n    stream.end();\n  });\n  // stream has ended\n  dbStream.on('end', function() {\n    stream.end();\n  });\n};\n\n/**\n * Insert A New Document\n *\n * @param {Object|Array} values\n * @param {Function} callback\n * @api public\n */\n\nCollection.prototype.insert = function insert(values, cb) {\n\n  var self = this;\n\n  // Normalize values to an array\n  if(!Array.isArray(values)) values = [values];\n\n  // Build a Document and add the values to a new array\n  var docs = values.map(function(value) {\n    return new Document(value, self.schema).values;\n  });\n\n  this.connection.db.collection(this.identity).insert(docs, function(err, results) {\n    if(err) return cb(err);\n    cb(null, utils.rewriteIds(results.ops, self.schema));\n  });\n};\n\n/**\n * Update Documents\n *\n * @param {Object} criteria\n * @param {Object} values\n * @param {Function} callback\n * @api public\n */\n\nCollection.prototype.update = function update(criteria, values, cb) {\n  var self = this,\n      query;\n\n  // Ignore `select` from waterline core\n  if (typeof criteria === 'object') {\n    delete criteria.select;\n  }\n\n  // Catch errors build query and return to the callback\n  try {\n    query = new Query(criteria, this.schema, this.config);\n  } catch(err) {\n    return cb(err);\n  }\n\n  values = new Document(values, this.schema).values;\n\n  // Mongo doesn't allow ID's to be updated\n  if(values.id) delete values.id;\n  if(values._id) delete values._id;\n\n  var collection = this.connection.db.collection(self.identity);\n\n  // Lookup records being updated and grab their ID's\n  // Useful for later looking up the record after an insert\n  // Required because options may not contain an ID\n  collection.find(query.criteria.where, {_id: 1}).toArray(function(err, records) {\n    if(err) return cb(err);\n    if(!records) return cb(Errors.NotFound);\n\n    // Build an array of records\n    var updatedRecords = [];\n\n    records.forEach(function(record) {\n      updatedRecords.push(record._id);\n    });\n\n    // Update the records\n    collection.update(query.criteria.where, { '$set': values }, { multi: true }, function(err, result) {\n      if(err) return cb(err);\n\n      // Look up newly inserted records to return the results of the update\n      collection.find({ _id: { '$in': updatedRecords }}).toArray(function(err, records) {\n        if(err) return cb(err);\n        cb(null, utils.rewriteIds(records, self.schema));\n      });\n    });\n  });\n};\n\n/**\n * Destroy Documents\n *\n * @param {Object} criteria\n * @param {Function} callback\n * @api public\n */\n\nCollection.prototype.destroy = function destroy(criteria, cb) {\n  var self = this,\n      query;\n\n  // Ignore `select` from waterline core\n  if (typeof criteria === 'object') {\n    delete criteria.select;\n  }\n\n  // Catch errors build query and return to the callback\n  try {\n    query = new Query(criteria, this.schema, this.config);\n  } catch(err) {\n    return cb(err);\n  }\n\n  var collection = this.connection.db.collection(self.identity);\n  collection.remove(query.criteria.where, function(err, results) {\n    if(err) return cb(err);\n\n    // Force to array to meet Waterline API\n    var resultsArray = [];\n\n    // If result is not an array return an array\n    if(!Array.isArray(results)) {\n      resultsArray.push({ id: results });\n      return cb(null, resultsArray);\n    }\n\n    // Create a valid array of IDs\n    results.forEach(function(result) {\n      resultsArray.push({ id: result });\n    });\n\n    cb(null, utils.rewriteIds(resultArray, self.schema));\n  });\n};\n\n/**\n * Count Documents\n *\n * @param {Object} criteria\n * @param {Function} callback\n * @api public\n */\n\nCollection.prototype.count = function count(criteria, cb) {\n\n  var self = this;\n  var query;\n\n  // Ignore `select` from waterline core\n  if (typeof criteria === 'object') {\n    delete criteria.select;\n  }\n\n  // Catch errors build query and return to the callback\n  try {\n    query = new Query(criteria, this.schema, this.config);\n  } catch(err) {\n    return cb(err);\n  }\n\n  this.connection.db.collection(this.identity).count(query.criteria.where, function(err, count) {\n    if (err) return cb(err);\n    cb(null, count);\n  });\n};\n\n\n/////////////////////////////////////////////////////////////////////////////////\n// PRIVATE METHODS\n/////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Get name of primary key field for this collection\n *\n * @return {String}\n * @api private\n */\nCollection.prototype._getPK = function _getPK () {\n  var self = this;\n  var pk;\n\n  _.keys(this.schema).forEach(function(key) {\n    if(self.schema[key].primaryKey) pk = key;\n  });\n\n  if(!pk) pk = 'id';\n  return pk;\n};\n\n\n/**\n * Parse Collection Definition\n *\n * @param {Object} definition\n * @api private\n */\n\nCollection.prototype._parseDefinition = function _parseDefinition(definition) {\n  var self = this;\n\n  // Hold the Schema\n  this.schema = _.cloneDeep(definition.definition);\n\n  if (_.has(this.schema, 'id') && this.schema.id.primaryKey && this.schema.id.type === 'integer') {\n    this.schema.id.type = 'objectid';\n  }\n\n  // Remove any Auto-Increment Keys, Mongo currently doesn't handle this well without\n  // creating additional collection for keeping track of the increment values\n  Object.keys(this.schema).forEach(function(key) {\n    if(self.schema[key].autoIncrement) delete self.schema[key].autoIncrement;\n  });\n\n  // Replace any foreign key value types with ObjectId\n  Object.keys(this.schema).forEach(function(key) {\n    if(self.schema[key].foreignKey) {\n      self.schema[key].type = 'objectid';\n    }\n  });\n\n  // Set the identity\n\tvar ident = definition.tableName ? definition.tableName : definition.identity.toLowerCase();\n\tthis.identity = _.clone(ident);\n};\n\n/**\n * Build Internal Indexes Dictionary based on the current schema.\n *\n * @api private\n */\n\nCollection.prototype._buildIndexes = function _buildIndexes() {\n  var self = this;\n\n  Object.keys(this.schema).forEach(function(key) {\n    var index = {};\n    var options = {};\n\n    // If index key is `id` ignore it because Mongo will automatically handle this\n    if(key === 'id') {\n      return;\n    }\n\n    // Handle Unique Indexes\n    if(self.schema[key].unique) {\n\n      // Set the index sort direction, doesn't matter for single key indexes\n      index[key] = 1;\n\n      // Set the index options\n      options.sparse = true;\n      options.unique = true;\n\n      // Store the index in the collection\n      self.indexes.push({ index: index, options: options });\n      return;\n    }\n\n    // Handle non-unique indexes\n    if(self.schema[key].index) {\n\n      // Set the index sort direction, doesn't matter for single key indexes\n      index[key] = 1;\n\n      // Set the index options\n      options.sparse = true;\n\n      // Store the index in the collection\n      self.indexes.push({ index: index, options: options });\n      return;\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-sails-mongo/node_modules/sails-mongo/lib/utils.js":"\n/**\n * Module Dependencies\n */\n\nvar url = require('url');\nvar _ = require('@sailshq/lodash');\nvar mongodb = require('mongodb');\n\nvar ObjectId = mongodb.ObjectID;\nvar MongoBinary = mongodb.Binary;\n\n\n/**\n * ignore\n */\n\nexports.object = {};\n\n/**\n * Safer helper for hasOwnProperty checks\n *\n * @param {Object} obj\n * @param {String} prop\n * @return {Boolean}\n * @api public\n */\n\nvar hop = Object.prototype.hasOwnProperty;\nexports.object.hasOwnProperty = function(obj, prop) {\n  return hop.call(obj, prop);\n};\n\n\n/**\n * Re-Write Mongo's _id attribute to a normalized id attribute in single document\n *\n * @param {Object} models\n * @api private\n */\n\nexports._rewriteIds = function(model, schema) {\n  if (hop.call(model, '_id')) {\n    // change id to string only if it's necessary\n    if (typeof model._id === 'object' && model._id._bsontype)\n      model.id = model._id.toString();\n    else\n      model.id = model._id;\n    delete model._id;\n  }\n\n  // Rewrite any foreign keys if a schema is available\n  if (!schema) return model;\n\n  Object.keys(schema).forEach(function (key) {\n    var foreignKey = schema[key].foreignKey || false;\n\n    // If a foreignKey, check if value matches a mongo id and if so turn it into an objectId\n    if (foreignKey && model[key] instanceof ObjectId) {\n      model[key] = model[key].toString();\n    }\n  });\n\n  return model;\n};\n\n/**\n * Re-Write Mongo's _id attribute to a normalized id attribute\n *\n * @param {Array} models\n * @api public\n */\n\nexports.rewriteIds = function rewriteIds(models, schema) {\n  var _models = models.map(function(model){\n    return exports._rewriteIds(model, schema);\n  });\n  return _models;\n};\n\n/**\n * Normalize documents retrieved from MongoDB to match Waterline's expectations\n *\n * @param {Array} models\n * @api public\n */\n\nexports.normalizeResults = function normalizeResults(models, schema) {\n  var _models = models.map(function (model) {\n    var _model = exports._rewriteIds(model, schema);\n    Object.keys(_model).forEach(function (key) {\n      if (model[key] instanceof MongoBinary && _.has(_model[key], 'buffer')) {\n        _model[key] = _model[key].buffer;\n      }\n    });\n    return _model;\n  });\n  return _models;\n};\n\n/**\n * Check if an ID resembles a Mongo BSON ID.\n * Can't use the `hop` helper above because BSON ID's will have their own hasOwnProperty value.\n *\n * @param {String} id\n * @return {Boolean}\n * @api public\n */\n\nexports.matchMongoId = function matchMongoId(id) {\n  if (id === null) return false;\n  var test = _.cloneDeep(id);\n  if(typeof test.toString !== 'undefined') test = id.toString();\n  return test.match(/^[a-fA-F0-9]{24}$/) ? true : false;\n};\n\n/**\n * Case Insensitive\n *\n * Wrap a value in a case insensitive regex\n * /^foobar$/i\n *\n * NOTE: this is really bad for production currently,\n * when you use a regex in the query it won't hit any\n * indexes. We need to fix this ASAP but for now it passes\n * all the waterline tests.\n *\n * @param {String} val\n * @return {String}\n * @api public\n */\n\nexports.caseInsensitive = function caseInsensitive(val) {\n  if(!_.isString(val)) return val;\n  return val.replace(/[-[\\]{}()+?*.\\/,\\\\^$|#]/g, \"\\\\$&\");\n};\n\n/**\n * Parse URL string from config\n *\n * Parse URL string into connection config parameters\n *\n * @param {Object} config\n * @return {Object}\n * @api public\n */\n\nexports.parseUrl = function parseUrl(config) {\n  if(!_.isString(config.url)) return config;\n\n  var obj = url.parse(config.url);\n\n  config.host = obj.hostname || config.host;\n  config.port = obj.port || config.port;\n\n  if(_.isString(obj.path)) {\n    config.database = obj.path.split(\"/\")[1] || config.database;\n  }\n\n  if(_.isString(obj.auth)) {\n    config.user = obj.auth.split(\":\")[0] || config.user;\n    config.password = obj.auth.split(\":\")[1] || config.password;\n  }\n\n  return config;\n};\n\n/**\n * Return a WLValidationError if the provided error was\n * caused by a unique constraint violation; otherwise,\n * return the existing error\n *\n * @param {Error} err\n * @return {Error}\n * @api public\n */\n\nexports.clarifyError = function clarifyError(err) {\n  // MongoDB duplicate key error code\n  if(err.code !== 11000) {\n    return err;\n  }\n\n  // Example errmsg: `E11000 duplicate key error index: db_name.model_name.$attribute_name_1 dup key: { : \"value\" }`\n  var matches = /E11000 duplicate key error index: .*?\\..*?\\.\\$(.*?)_\\d+\\s+dup key: { : (.*) }$/.exec(err.errmsg);\n  if (!matches) {\n    // Example errmsg: E11000 duplicate key error collection: db_name.model_name index: attribute_name_1 dup key: { : \"value\" }\n    matches = /E11000 duplicate key error collection: .*?\\..*? index: (.*?)_\\d+\\s+dup key: { : (.*) }$/.exec(err.errmsg);\n    if (!matches) {\n      // We cannot parse error message, return original error\n      return err;\n    }\n  }\n  var fieldName = matches[1]; // name of index (without _[digits] at the end)\n  var value;\n  try {\n    value = JSON.parse(matches[2]); // attempt to convert the value to a primitive representation\n  } catch (x) {\n    value = matches[2]; // for non-serializable objects (e.g. ObjectId representations), return as-is\n  }\n\n  var validationError = {\n    code: 'E_UNIQUE',\n    invalidAttributes: {},\n    originalError: err\n  };\n\n  validationError.invalidAttributes[fieldName] = [\n    {\n      rule: 'unique',\n      value: value\n    }\n  ];\n\n  return validationError;\n};\n","/home/travis/build/npmtest/node-npmtest-sails-mongo/node_modules/sails-mongo/lib/document.js":"/**\n * Module Dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar ObjectId = require('mongodb').ObjectID;\nvar utils = require('./utils');\nvar hasOwnProperty = utils.object.hasOwnProperty;\n\n\n/**\n * Document\n *\n * Represents a single document in a collection. Responsible for serializing values before\n * writing to a collection.\n *\n * @param {Object} values\n * @param {Object} schema\n * @api private\n */\n\nvar Document = module.exports = function Document(values, schema) {\n\n  // Keep track of the current document's values\n  this.values = {};\n\n  // Grab the schema for normalizing values\n  this.schema = schema || {};\n\n  // If values were passed in, use the setter\n  if(values) this.values = this.setValues(values);\n\n  return this;\n};\n\n\n/////////////////////////////////////////////////////////////////////////////////\n// PRIVATE METHODS\n/////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Set values\n *\n * Normalizes values into proper formats.\n *\n * @param {Object} values\n * @return {Object}\n * @api private\n */\n\nDocument.prototype.setValues = function setValues(values) {\n  this.serializeValues(values);\n  this.normalizeId(values);\n\n  return values;\n};\n\n/**\n * Normalize ID's\n *\n * Moves values.id into the preferred mongo _id field.\n *\n * @param {Object} values\n * @api private\n */\n\nDocument.prototype.normalizeId = function normalizeId(values) {\n\n  if(!values.id) return;\n\n  // Check if data.id looks like a MongoID\n  if(_.isString(values.id) && values.id.match(/^[a-fA-F0-9]{24}$/)) {\n\n    values._id = new ObjectId.createFromHexString(values.id);\n  } else {\n\n    values._id = _.cloneDeep(values.id);\n  }\n\n  delete values.id;\n};\n\n/**\n * Serialize Insert Values\n *\n * @param {Object} values\n * @return {Object}\n * @api private\n */\n\nDocument.prototype.serializeValues = function serializeValues(values) {\n  var self = this;\n\n  Object.keys(values).forEach(function(key) {\n    if(!hasOwnProperty(self.schema, key)) return;\n\n    var type = self.schema[key].type,\n        val;\n\n    var foreignKey = self.schema[key].foreignKey || false;\n\n    if(_.isUndefined(values[key])) return;\n\n    // If a foreignKey, check if value matches a mongo id and if so turn it into an objectId\n    if(foreignKey && utils.matchMongoId(values[key])) {\n      values[key] = new ObjectId.createFromHexString(values[key]);\n    }\n\n    if(type === 'json') {\n      try {\n        val = JSON.parse(values[key]);\n      } catch(e) {\n        return;\n      }\n      values[key] = val;\n    }\n  });\n\n  return values;\n};\n","/home/travis/build/npmtest/node-npmtest-sails-mongo/node_modules/sails-mongo/lib/query/index.js":"\n/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar ObjectId = require('mongodb').ObjectID;\nvar validator = require('validator');\nvar Aggregate = require('./aggregate');\nvar utils = require('../utils');\nvar hop = utils.object.hasOwnProperty;\n\n/**\n * Query Constructor\n *\n * Normalizes Waterline queries to work with Mongo.\n *\n * @param {Object} options\n * @param {Object} [config]\n * @api private\n */\n\nvar Query = module.exports = function Query(options, schema, config) {\n\n  // Flag as an aggregate query or not\n  this.aggregate = false;\n\n  // Cache the schema for use in parseTypes\n  this.schema = schema;\n\n  // Hold the config object\n  this.config = config || {};\n\n  // Check for Aggregate Options\n  this.checkAggregate(options);\n\n  // Retrieve select fields from criteria\n  if (options && typeof options === 'object' && options.select) {\n    this.select = this.parseSelect(options.select);\n    delete options.select;\n  } else {\n    this.select = {};\n  }\n\n  // Normalize Criteria\n  this.criteria = this.normalizeCriteria(options);\n\n  return this;\n};\n\n/**\n * Check For Aggregates\n *\n * Checks the options to determine if an aggregate query is needed.\n *\n * @param {Object} options\n * @api private\n */\n\nQuery.prototype.checkAggregate = function checkAggregate(options) {\n  var aggregateOptions = ['groupBy', 'sum', 'average', 'min', 'max'];\n  var aggregates = _.intersection(aggregateOptions, Object.keys(options));\n\n  if(aggregates.length === 0) return options;\n\n  this.aggregateGroup = new Aggregate(options);\n  this.aggregate = true;\n};\n\n\n/**\n * Normalize Criteria\n *\n * Transforms a Waterline Query into a query that can be used\n * with MongoDB. For example it sets '>' to $gt, etc.\n *\n * @param {Object} options\n * @return {Object}\n * @api private\n */\n\nQuery.prototype.normalizeCriteria = function normalizeCriteria(options) {\n  \"use strict\";\n  var self = this;\n\n  return _.mapValues(options, function (original, key) {\n    if (key === 'where') return self.parseWhere(original);\n    if (key === 'sort')  return self.parseSort(original);\n    return original;\n  });\n};\n\n\n/**\n * Parse Where\n *\n * <where> ::= <clause>\n *\n * @api private\n *\n * @param original\n * @returns {*}\n */\nQuery.prototype.parseWhere = function parseWhere(original) {\n  \"use strict\";\n  var self = this;\n\n  // Fix an issue with broken queries when where is null\n  if(_.isNull(original)) return {};\n\n  return self.parseClause(original);\n};\n\n\n/**\n * Parse Clause\n *\n * <clause> ::= { <clause-pair>, ... }\n *\n * <clause-pair> ::= <field> : <expression>\n *                 | or|$or: [<clause>, ...]\n *                 | $or   : [<clause>, ...]\n *                 | $and  : [<clause>, ...]\n *                 | $nor  : [<clause>, ...]\n *                 | like  : { <field>: <expression>, ... }\n *\n * @api private\n *\n * @param original\n * @returns {*}\n */\nQuery.prototype.parseClause = function parseClause(original) {\n  \"use strict\";\n  var self = this;\n\n  return _.reduce(original, function parseClausePair(obj, val, key) {\n    \"use strict\";\n\n    // Normalize `or` key into mongo $or\n    if (key.toLowerCase() === 'or') key = '$or';\n\n    // handle Logical Operators\n    if (['$or', '$and', '$nor'].indexOf(key) !== -1) {\n      // Value of $or, $and, $nor require an array, else ignore\n      if (_.isArray(val)) {\n        val = _.map(val, function (clause) {\n          return self.parseClause(clause);\n        });\n\n        obj[key] = val;\n      }\n    }\n\n    // handle Like Operators for WQL (Waterline Query Language)\n    else if (key.toLowerCase() === 'like') {\n      // transform `like` clause into multiple `like` operator expressions\n      _.extend(obj, _.reduce(val, function parseLikeClauses(likes, expression, field) {\n        likes[field] = self.parseExpression(field, { like: expression });\n        return likes;\n      }, {}));\n    }\n\n    // Default\n    else {\n      val = self.parseExpression(key, val);\n\n      // Normalize `id` key into mongo `_id`\n      if (key === 'id' && !hop(this, '_id')) key = '_id';\n\n      obj[key] = val;\n    }\n\n    return obj;\n  }, {}, original);\n};\n\n\n/**\n * Parse Expression\n *\n * <expression> ::= { <!|not>: <value> | [<value>, ...] }\n *                | { <$not>: <expression>, ... }\n *                | { <modifier>: <value>, ... }\n *                | [<value>, ...]\n *                | <value>\n\n * @api private\n *\n * @param field\n * @param expression\n * @returns {*}\n */\nQuery.prototype.parseExpression = function parseExpression(field, expression) {\n  \"use strict\";\n  var self = this;\n\n  // Recursively parse nested unless value is a date\n  if (_.isPlainObject(expression) && !_.isDate(expression)) {\n    return _.reduce(expression, function (obj, val, modifier) {\n\n      // Handle `not` by transforming to $not, $ne or $nin\n      if (modifier === '!' || modifier.toLowerCase() === 'not') {\n\n        if (_.isPlainObject(val) && !_.has(val, '_bsontype')) {\n          obj['$not'] = self.parseExpression(field, val);\n          return obj;\n        }\n\n        modifier = _.isArray(val) ? '$nin' : '$ne';\n        val = self.parseValue(field, modifier, val);\n        obj[modifier] = val;\n        return obj;\n      }\n\n      // WQL Evaluation Modifiers for String\n      if (_.isString(val)) {\n        // Handle `contains` by building up a case insensitive regex\n        if(modifier === 'contains') {\n          val = utils.caseInsensitive(val);\n          val =  '[\\\\s\\\\S]*' + val + '[\\\\s\\\\S]*';\n          obj['$regex'] = new RegExp('^' + val + '$', 'i');\n          return obj;\n        }\n\n        // Handle `like`\n        if(modifier === 'like') {\n          val = utils.caseInsensitive(val);\n          val = val.replace(/%/g, '[\\\\s\\\\S]*');\n          obj['$regex'] = new RegExp('^' + val + '$', 'i');\n          return obj;\n        }\n\n        // Handle `startsWith` by setting a case-insensitive regex\n        if(modifier === 'startsWith') {\n          val = utils.caseInsensitive(val);\n          val =  val + '[\\\\s\\\\S]*';\n          obj['$regex'] = new RegExp('^' + val + '$', 'i');\n          return obj;\n        }\n\n        // Handle `endsWith` by setting a case-insensitive regex\n        if(modifier === 'endsWith') {\n          val = utils.caseInsensitive(val);\n          val =  '[\\\\s\\\\S]*' + val;\n          obj['$regex'] = new RegExp('^' + val + '$', 'i');\n          return obj;\n        }\n      }\n\n      // Handle `lessThan` by transforming to $lt\n      if(modifier === '<' || modifier === 'lessThan' || modifier.toLowerCase() === 'lt') {\n        obj['$lt'] = self.parseValue(field, modifier, val);\n        return obj;\n      }\n\n      // Handle `lessThanOrEqual` by transforming to $lte\n      if(modifier === '<=' || modifier === 'lessThanOrEqual' || modifier.toLowerCase() === 'lte') {\n        obj['$lte'] = self.parseValue(field, modifier, val);\n        return obj;\n      }\n\n      // Handle `greaterThan` by transforming to $gt\n      if(modifier === '>' || modifier === 'greaterThan' || modifier.toLowerCase() === 'gt') {\n        obj['$gt'] = self.parseValue(field, modifier, val);\n        return obj;\n      }\n\n      // Handle `greaterThanOrEqual` by transforming to $gte\n      if(modifier === '>=' || modifier === 'greaterThanOrEqual' || modifier.toLowerCase() === 'gte') {\n        obj['$gte'] = self.parseValue(field, modifier, val);\n        return obj;\n      }\n\n      obj[modifier] = self.parseValue(field, modifier, val);\n      return obj;\n    }, {});\n  }\n\n  // <expression> ::= [value, ...], normalize array into mongo $in operator expression\n  if (_.isArray(expression)) {\n    return { $in: self.parseValue(field, '$in', expression) };\n  }\n\n  // <expression> ::= <value>, default equal expression\n  return self.parseValue(field, undefined, expression);\n};\n\n\n/**\n * Parse Value\n *\n * <value> ::= RegExp | Number | String\n *           | [<value>, ...]\n *           | <plain object>\n *\n * @api private\n *\n * @param field\n * @param modifier\n * @param val\n * @returns {*}\n */\nQuery.prototype.parseValue = function parseValue(field, modifier, val) {\n  \"use strict\";\n  var self = this;\n\n  // Omit adding regex value to these modifiers\n  var omitRegExModifiers = ['$ne', 'greaterThan', '>', 'gt', 'greaterThanOrEqual',\n                            '>=', 'gte', '$gt', '$gte', '<', 'lessThan', '<=',\n                            'lessThanOrEqual'\n                           ];\n\n  // Look and see if the key is in the schema, id attribute and all association\n  // attributes are objectid type by default (@see { @link collection._parseDefinition }).\n  if (hop(self.schema, field) && self.schema[field].type === 'objectid') {\n\n    // Check for array of Mongo ObjectId\n    // If we have an array of IDs, attempt to make ObjectIds out of them.\n    if (_.isArray(val)) {\n      return _.map(val, function (item) {\n        return _.isString(item) && utils.matchMongoId(item) ? new ObjectId(item) : item;\n      });\n    }\n\n    // Check for Mongo ObjectId\n    if (_.isString(val) && utils.matchMongoId(val)) {\n      return new ObjectId(val.toString());\n    }\n\n  }\n\n  if(_.isString(val)) {\n\n    // If we can verify that the field is NOT a string type, translate\n    // certain values into booleans, date or null.  Otherwise they'll be left\n    // as strings.\n    if (hop(self.schema, field) && self.schema[field].type != 'string') {\n\n      if(self.schema[field].type === 'integer'){\n        return parseInt(val);\n      }\n\n      if(self.schema[field].type === 'float'){\n        return parseFloat(val);\n      }\n\n      if (val === \"false\") {\n        return false;\n      }\n\n      if (val === \"true\") {\n        return true;\n      }\n\n      if (val === \"null\") {\n        return null;\n      }\n\n      if (self.schema[field].type === 'datetime') {\n        return new Date(val);\n      }\n\n      if (self.schema[field].type === 'date') {\n        return new Date(val);\n      }\n\n    }\n\n    if (omitRegExModifiers.indexOf(modifier) > -1) {\n      return val;\n    }\n\n\n    // Only if it's not mongodbID, for most of case usage would like:\n    // user.find('56173df732776c64852f8c91')\n    //\n    // Turn wlNext.caseSensitive flag to `true` to enable case sensitive requests when there is no modifier\n    if(!validator.isMongoId(val) && !this.config.caseSensitive){\n      // Replace Percent Signs, work in a case insensitive fashion by default\n      val = utils.caseInsensitive(val);\n      val = val.replace(/%/g, '[\\\\s\\\\S]*');\n      val = new RegExp('^' + val + '$', 'i');\n    }\n\n    return val;\n  }\n\n  // Array, RegExp, plain object, number\n  return val;\n};\n\n\n/**\n * Parse Sort\n *\n * @param original\n * @returns {*}\n */\nQuery.prototype.parseSort = function parseSort(original) {\n  \"use strict\";\n  return _.reduce(original, function (sort, order, field) {\n    // Normalize id, if used, into _id\n    if (field === 'id') field = '_id';\n\n    // Handle Sorting Order with binary or -1/1 values\n    sort[field] = ([0, -1].indexOf(order) > -1) ? -1 : 1;\n\n    return sort;\n  }, {});\n};\n/**\n *\n * Parse Select\n *\n * @param original\n * @returns {*}\n */\nQuery.prototype.parseSelect = function parseSelect(original) {\n  var select = {};\n\n  _.each(original, function (field) {\n    select[field] = 1;\n  });\n\n  return select;\n};\n","/home/travis/build/npmtest/node-npmtest-sails-mongo/node_modules/sails-mongo/lib/query/aggregate.js":"/**\n * Module dependencies\n */\n\nvar Errors = require('waterline-errors').adapter;\n\n/**\n * Aggregate Constructor\n *\n * Generates aggregation objects for use with the Mongo Aggregation pipeline.\n *\n * @param {Object} options\n * @api private\n */\n\nvar Aggregate = module.exports = function Aggregate(options) {\n\n  // Hold the criteria\n  this.group = {};\n\n  // Build the group phase for an aggregation\n  this.build(options);\n\n  return this.group;\n};\n\n/**\n * Build\n *\n * Builds up an aggregate query criteria object from a\n * Waterline criteria object.\n *\n * @param {Object} options\n * @api private\n */\n\nAggregate.prototype.build = function build(options) {\n  var self = this,\n      aggregateGroup = {},\n      aggregations = [];\n\n  // Check if we have calculations to do\n  if(!options.sum && !options.average && !options.min && !options.max) {\n    throw Errors.InvalidGroupBy;\n  }\n\n  // Create the beginnings of the $group aggregation phase\n  this.group = { _id: this.groupBy(options) };\n\n  // Build up the group for the $group aggregation phase\n  if(Array.isArray(options.sum)) {\n    options.sum.forEach(function(opt) {\n      self.group[opt] = { '$sum': '$' + opt };\n    });\n  }\n\n  if(Array.isArray(options.average)) {\n    options.average.forEach(function(opt) {\n      self.group[opt] = { '$avg': '$' + opt };\n    });\n  }\n\n  if(Array.isArray(options.min)) {\n    options.min.forEach(function(opt) {\n      self.group[opt] = { '$min': '$' + opt };\n    });\n  }\n\n  if(Array.isArray(options.max)) {\n    options.max.forEach(function(opt) {\n      self.group[opt] = { '$max': '$' + opt };\n    });\n  }\n};\n\n/**\n * Group By\n *\n * Builds up the aggregation _id $group phase.\n *\n * @param {Object} options\n * @api private\n */\n\nAggregate.prototype.groupBy = function groupBy(options) {\n  var group = {};\n\n  if(!options.groupBy) return null;\n  if(!Array.isArray(options.groupBy)) return null;\n\n  options.groupBy.forEach(function(key) {\n    group[key] = '$' + key;\n  });\n\n  return group;\n};\n"}